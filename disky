#!/usr/bin/env bash
#
# disky - Interactive disc space analysis with expandable tree view
# Usage: ./disky [directory]   OR   bash disky [directory]
# (Do not run with Python; this is a Bash script.)
#

# Don't use set -e: clear/du/read can fail in normal use (non-TTY, permissions)
set +e
IFS=$'\n'

# Colors (optional, can disable if terminal doesn't support)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NORM='\033[0m'

# Box-drawing characters for tree
TREE_BRANCH="├── "
TREE_LAST="└── "
TREE_LINE="│   "
TREE_NONE="    "

# Bar width for disk gauge
BAR_WIDTH=28

# Config
ROOT="${1:-.}"
ROOT="$(cd "$ROOT" 2>/dev/null && pwd)" || { echo "Invalid directory: $1"; exit 1; }
CACHE_DIR="${TMPDIR:-/tmp}/disky_$$"
mkdir -p "$CACHE_DIR"
# Restore terminal on exit so keypresses don't echo as ^[[A etc.
saved_stty=""
trap 'rm -rf "$CACHE_DIR"; [[ -n "$saved_stty" ]] && stty "$saved_stty" 2>/dev/null' EXIT

# State
expanded_paths=""
cursor=0
tree_scroll_offset=0
NAVIGATING_UP=0
TREE_DIRTY=1
declare -a visible_depths visible_paths visible_names visible_sizes visible_isdir visible_expanded visible_has_sibling

# Reserve this many lines for header (gauge, overview, title). Tree uses the rest.
HEADER_LINES=14

# Get disk stats for the volume containing path (total, used, avail, pct)
get_disk_stats() {
  local path="$1"
  local line
  line=$(df -h "$path" 2>/dev/null | awk 'NR==2')
  if [[ -z "$line" ]]; then
    echo "?" "?" "?" "0"
    return
  fi
  local total used avail pct
  total=$(echo "$line" | awk '{print $2}')
  used=$(echo "$line" | awk '{print $3}')
  avail=$(echo "$line" | awk '{print $4}')
  pct=$(echo "$line" | awk '{gsub(/%/,"",$5); print $5+0}')
  [[ -z "$pct" || "$pct" -lt 0 ]] && pct=0
  [[ "$pct" -gt 100 ]] && pct=100
  echo "$total" "$used" "$avail" "$pct"
}

# Draw ASCII art disk gauge (total / used / bar)
draw_disk_gauge() {
  local total="$1" used="$2" avail="$3" pct="$4"
  local filled empty i
  (( filled = (pct * BAR_WIDTH) / 100 )) || filled=0
  (( empty = BAR_WIDTH - filled )) || empty=BAR_WIDTH
  [[ $filled -gt $BAR_WIDTH ]] && filled=$BAR_WIDTH && empty=0
  [[ $empty -lt 0 ]] && empty=0
  echo -e "${DIM}     ___${NORM}"
  echo -e "${DIM}   /   \\${NORM}"
  echo -e "${DIM}  | ${BOLD}${CYAN}DISK${NORM}${DIM} |${NORM}   ${BOLD}Total:${NORM} ${YELLOW}$total${NORM}   ${BOLD}Used:${NORM} ${RED}$used${NORM}   ${BOLD}Free:${NORM} ${GREEN}$avail${NORM}"
  echo -e "${DIM}  |${NORM} ${GREEN}$(printf '%*s' "$filled" '' | tr ' ' '=')${NORM}${DIM}$(printf '%*s' "$empty" '' | tr ' ' '-')${NORM} ${DIM}|${NORM}  ${BOLD}${pct}%${NORM} used"
  echo -e "${DIM}   \\___/${NORM}"
}

# Overview: home or root (/) top-level dirs by size. Cached to avoid slow du on every redraw.
OVERVIEW_CACHE="$CACHE_DIR/overview"
overview_filled=0
[[ "$ROOT" == "/" ]] && OVERVIEW_LABEL="Root (/)" || OVERVIEW_LABEL="Home (~)"

get_overview_data() {
  local scope_path
  if [[ "$ROOT" == "/" ]]; then
    scope_path="/"
  else
    scope_path="${HOME:-$ROOT}"
  fi
  # du -sk gives numbers for bar scaling; timeout when available (e.g. Linux/Homebrew)
  local tmp
  if command -v timeout &>/dev/null; then
    tmp=$(timeout 4 du -sk "$scope_path"/*/ 2>/dev/null | sort -rn | head -8)
  else
    tmp=$(du -sk "$scope_path"/*/ 2>/dev/null | sort -rn | head -8)
  fi
  if [[ -z "$tmp" ]]; then
    return
  fi
  local max_kb=0
  while read -r size_kb path; do
    [[ -z "$size_kb" || "$size_kb" =~ ^[^0-9] ]] && continue
    [[ $size_kb -gt $max_kb ]] && max_kb=$size_kb
  done <<< "$tmp"
  [[ $max_kb -eq 0 ]] && return
  while read -r size_kb path; do
    [[ -z "$size_kb" || "$size_kb" =~ ^[^0-9] ]] && continue
    local name
    name=$(basename "$path" 2>/dev/null)
    name="${name:0:14}"
    local bar_len
    (( bar_len = (size_kb * BAR_WIDTH) / max_kb )) || bar_len=0
    [[ $bar_len -gt $BAR_WIDTH ]] && bar_len=$BAR_WIDTH
    local human
    human=$(kb_to_human "$size_kb")
    echo "${bar_len}|${name}|${human}"
  done <<< "$tmp" > "$OVERVIEW_CACHE"
  overview_filled=1
}

kb_to_human() {
  local kb=$1
  if [[ $kb -ge 1048576 ]]; then
    echo "$(( kb / 1048576 ))G"
  elif [[ $kb -ge 1024 ]]; then
    echo "$(( kb / 1024 ))M"
  else
    echo "${kb}K"
  fi
}

draw_overview() {
  # Only read from cache; population runs in background at startup
  if [[ ! -f "$OVERVIEW_CACHE" || ! -s "$OVERVIEW_CACHE" ]]; then
    echo -e "${DIM}  ${OVERVIEW_LABEL} top usage: (loading...)${NORM}"
    return
  fi
  echo -e "${DIM}  ${OVERVIEW_LABEL} — largest:${NORM}"
  local bar_len name human
  while IFS='|' read -r bar_len name human; do
    [[ -z "$bar_len" ]] && continue
    local bar
    bar=$(printf '%*s' "$bar_len" '' | tr ' ' '=')
    printf "    ${CYAN}%-14s${NORM} ${GREEN}%s${NORM} ${DIM}%s${NORM}\n" "$name" "$bar" "$human"
  done < "$OVERVIEW_CACHE"
}

# Encode path for use as cache filename (safe for all chars)
path_to_cache_key() {
  echo -n "$1" | od -A n -t x1 | tr -d ' \n'
}

# Get directory listing with sizes (cached)
get_listing() {
  local path="$1"
  local key
  key=$(path_to_cache_key "$path")
  local cache_file="$CACHE_DIR/$key"
  if [[ -f "$cache_file" ]]; then
    cat "$cache_file"
    return
  fi
  local list=""
  local item size
  if [[ ! -d "$path" ]]; then
    return
  fi
  while IFS= read -r item; do
    [[ -z "$item" ]] && continue
    [[ "$item" == "." || "$item" == ".." ]] && continue
    if [[ -d "$path/$item" ]]; then
      size=$(du -sh "$path/$item" 2>/dev/null | cut -f1) || size="?"
      list="$list${size}\t${item}\tdir\n"
    else
      size=$(du -h "$path/$item" 2>/dev/null | cut -f1) || size="?"
      list="$list${size}\t${item}\tfile\n"
    fi
  done < <(ls -A "$path" 2>/dev/null)
  echo -e "$list" > "$cache_file"
  echo -e "$list"
}

is_expanded() {
  local path="$1"
  case "$expanded_paths" in
    *$'\n'"$path"$'\n'*) return 0 ;;
    *$'\n'"$path") return 0 ;;
    "$path"$'\n'*) return 0 ;;
    "$path") return 0 ;;
    *) return 1 ;;
  esac
}

set_expanded() {
  local path="$1"
  if ! is_expanded "$path"; then
    expanded_paths="$expanded_paths$path"$'\n'
  fi
  TREE_DIRTY=1
}

set_collapsed() {
  local path="$1"
  # Remove this path and any path under it (safe for special chars in path)
  expanded_paths=$(echo "$expanded_paths" | while IFS= read -r p; do
    [[ -n "$p" && "$p" != "$path" && "$p" != "$path"/* ]] && echo "$p"
  done)
  TREE_DIRTY=1
}

# Build flattened visible tree (depths, paths, names, sizes, isdir, expanded, has_sibling)
build_visible_tree() {
  visible_depths=()
  visible_paths=()
  visible_names=()
  visible_sizes=()
  visible_isdir=()
  visible_expanded=()
  visible_has_sibling=()

  # ".." row to navigate up (only when not at filesystem root)
  if [[ "$ROOT" != "/" ]]; then
    local parent="${ROOT%/*}"
    [[ -z "$parent" ]] && parent="/"
    visible_depths+=(0)
    visible_paths+=("$parent")
    visible_names+=("..")
    visible_sizes+=("")
    visible_isdir+=(1)
    visible_expanded+=(0)
    visible_has_sibling+=(1)
  fi

  # Root row
  local root_size
  root_size=$(du -sh "$ROOT" 2>/dev/null | cut -f1) || root_size="?"
  visible_depths+=(0)
  visible_paths+=("$ROOT")
  visible_names+=(".")
  visible_sizes+=("${root_size:-?}")
  visible_isdir+=(1)
  visible_expanded+=(1)
  visible_has_sibling+=(1)  # root always has children below
  _build_visible "$ROOT" "." 1
}

_build_visible() {
  local path="$1"
  local name="$2"
  local depth=$3
  local listing line size n isdir has_sibling
  local -a names sizes isdirs paths

  if [[ -n "$name" ]]; then
    # Add this directory's children (directory itself was already added by parent)
    listing=$(get_listing "$path")
    if [[ -z "$listing" ]]; then
      # Empty or unreadable - nothing to add
      return
    fi
    # Count lines for has_sibling
    local count=0
    while IFS= read -r line; do
      [[ -z "$line" ]] && continue
      ((count++)) || true
    done <<< "$(echo -e "$listing")"
    local idx=0
    while IFS= read -r line; do
      [[ -z "$line" ]] && continue
      size=$(echo "$line" | cut -f1)
      n=$(echo "$line" | cut -f2)
      isdir=$(echo "$line" | cut -f3)
      ((idx++)) || true
      has_sibling=$(( idx < count ? 1 : 0 ))
      visible_depths+=("$depth")
      visible_paths+=("$path/$n")
      visible_names+=("$n")
      visible_sizes+=("$size")
      visible_isdir+=("$([[ "$isdir" == "dir" ]] && echo 1 || echo 0)")
      if [[ "$isdir" == "dir" ]]; then
        if is_expanded "$path/$n"; then
          visible_expanded+=("1")
          visible_has_sibling+=("$has_sibling")
          _build_visible "$path/$n" "$n" $(( depth + 1 ))
        else
          visible_expanded+=("0")
          visible_has_sibling+=("$has_sibling")
        fi
      else
        visible_expanded+=("0")
        visible_has_sibling+=("$has_sibling")
      fi
    done <<< "$(echo -e "$listing")"
    return
  fi
}

# Draw one line prefix (tree branches)
line_prefix() {
  local depth=$1
  local has_sibling=$2
  local d=0
  local out=""
  while [[ $d -lt $depth ]]; do
    # We need to know if any ancestor has a sibling - we don't have that here.
    # Use simple approach: all use TREE_LINE except at our depth.
    out="$out$TREE_LINE"
    ((d++)) || true
  done
  if [[ $has_sibling -eq 1 ]]; then
    out="$out$TREE_BRANCH"
  else
    out="$out$TREE_LAST"
  fi
  echo -n "$out"
}

render() {
  clear 2>/dev/null || true
  # Disk gauge (total / used / free) for the volume containing ROOT
  local total used avail pct
  IFS=' ' read -r total used avail pct <<< "$(get_disk_stats "$ROOT")"
  draw_disk_gauge "$total" "$used" "$avail" "$pct"
  echo ""
  draw_overview
  echo ""
  echo -e "${BOLD}${CYAN}disky${NORM} — disc space — ${DIM}$ROOT${NORM}"
  echo -e "${DIM}↑/↓ move  Enter/→ expand  ← collapse  u up  q quit${NORM}"
  echo ""

  local total=${#visible_names[@]}
  # How many tree lines fit (same as clamp_cursor)
  local term_lines
  term_lines=$(tput lines 2>/dev/null)
  [[ -z "$term_lines" || "$term_lines" -lt 10 ]] && term_lines=24
  local tree_height=$(( term_lines - HEADER_LINES ))
  [[ $tree_height -lt 3 ]] && tree_height=3
  # If list fits, show all; else show viewport
  local start=0 end=$total
  if [[ $total -gt $tree_height ]]; then
    start=$tree_scroll_offset
    end=$(( tree_scroll_offset + tree_height ))
    [[ $end -gt $total ]] && end=$total
  fi
  local i=$start
  while [[ $i -lt $end ]]; do
    local depth=${visible_depths[$i]}
    local name="${visible_names[$i]}"
    local size="${visible_sizes[$i]}"
    local isdir=${visible_isdir[$i]}
    local expanded=${visible_expanded[$i]}
    local has_sibling=${visible_has_sibling[$i]}

    # Tree prefix: we need "has_sibling" per level from root to here.
    # Our array only has has_sibling for current node. So we use it for the last segment only.
    local prefix=""
    local d=0
    while [[ $d -lt $depth ]]; do
      prefix="$prefix$TREE_LINE"
      ((d++)) || true
    done
    if [[ $has_sibling -eq 1 ]]; then
      prefix="$prefix$TREE_BRANCH"
    else
      prefix="$prefix$TREE_LAST"
    fi

    local display_name="$name"
    [[ $isdir -eq 1 && "$name" != ".." ]] && display_name="$name/"
    [[ "$name" == ".." ]] && display_name=".. (parent)"

    if [[ $i -eq $cursor ]]; then
      if [[ "$name" == ".." ]]; then
        echo -e "${BOLD}${GREEN}> ${NORM}${prefix}${BOLD}${display_name}${NORM}  ${DIM}(go up)${NORM}"
      else
        echo -e "${BOLD}${GREEN}> ${NORM}${prefix}${BOLD}${display_name}${NORM}  ${YELLOW}${size}${NORM}"
      fi
    else
      if [[ "$name" == ".." ]]; then
        echo -e "  ${prefix}${DIM}${display_name}${NORM}  ${DIM}(go up)${NORM}"
      elif [[ $isdir -eq 1 ]]; then
        [[ $expanded -eq 1 ]] && echo -e "  ${prefix}${BLUE}${display_name}${NORM}  ${DIM}${size}${NORM}" || echo -e "  ${prefix}${CYAN}${display_name}${NORM}  ${DIM}${size}${NORM}"
      else
        echo -e "  ${prefix}${display_name}  ${DIM}${size}${NORM}"
      fi
    fi
    ((i++)) || true
  done
  if [[ $total -gt $tree_height ]]; then
    echo -e "${DIM}  — $(( start + 1 ))-$end of $total —${NORM}"
  fi
}

# Ensure cursor is in valid range; keep scroll so cursor stays in visible window.
clamp_cursor() {
  local total=${#visible_names[@]}
  if [[ $cursor -ge $total ]]; then
    cursor=$(( total - 1 ))
  fi
  [[ $cursor -lt 0 ]] && cursor=0
  # Viewport: how many tree lines fit on screen
  local term_lines
  term_lines=$(tput lines 2>/dev/null)
  [[ -z "$term_lines" || "$term_lines" -lt 10 ]] && term_lines=24
  local tree_height=$(( term_lines - HEADER_LINES ))
  [[ $tree_height -lt 3 ]] && tree_height=3
  # Keep cursor in view
  if [[ $cursor -lt $tree_scroll_offset ]]; then
    tree_scroll_offset=$cursor
  fi
  if [[ $cursor -ge $(( tree_scroll_offset + tree_height )) ]]; then
    tree_scroll_offset=$(( cursor - tree_height + 1 ))
  fi
  # Clamp scroll to valid range
  if [[ $(( tree_scroll_offset + tree_height )) -gt $total ]]; then
    tree_scroll_offset=$(( total - tree_height ))
  fi
  [[ $tree_scroll_offset -lt 0 ]] && tree_scroll_offset=0
}

# Go up to parent directory (same as "cd .." then show that directory).
do_go_up() {
  [[ "$ROOT" == "/" ]] && return
  local new_root
  new_root=$(cd "$ROOT/.." 2>/dev/null && pwd)
  if [[ -z "$new_root" ]]; then
    new_root="${ROOT%/*}"
    [[ -z "$new_root" ]] && new_root="/"
  fi
  ROOT="$new_root"
  expanded_paths="$ROOT"$'\n'
  cursor=0
  tree_scroll_offset=0
  NAVIGATING_UP=1
  TREE_DIRTY=1
}

# Show loading screen while building tree (e.g. after navigating up).
show_loading_screen() {
  clear 2>/dev/null || true
  echo -e "${BOLD}${CYAN}disky${NORM} — loading parent directory"
  echo ""
  echo -e "  ${YELLOW}Scanning:${NORM} $ROOT"
  echo ""
  echo -e "  ${DIM}Computing sizes (this may take a moment for large directories)...${NORM}"
  echo ""
}

# Navigate up (when on first row and not at /) or expand directory. Used by Enter and Right.
# Row 0 is always ".." when ROOT != "/", so we use index instead of name to avoid encoding issues.
nav_up_or_expand() {
  local total=${#visible_names[@]}
  [[ $total -eq 0 ]] && return
  if [[ $cursor -eq 0 && "$ROOT" != "/" ]]; then
    do_go_up
  else
    local path="${visible_paths[$cursor]}"
    local isdir=${visible_isdir[$cursor]}
    [[ $isdir -eq 1 ]] && set_expanded "$path"
  fi
}

main_loop() {
  local key
  saved_stty=$(stty -g 2>/dev/null)
  stty -icanon -echo 2>/dev/null
  while true; do
    if [[ $TREE_DIRTY -eq 1 ]]; then
      if [[ $NAVIGATING_UP -eq 1 ]]; then
        show_loading_screen
        build_visible_tree
        NAVIGATING_UP=0
      else
        build_visible_tree
      fi
      TREE_DIRTY=0
    fi
    clamp_cursor
    render

    key=""
    read -rsn 1 key || key="q"
    if [[ "$key" == $'\x1b' ]]; then
      read -rsn 2 key || key=""
      case "$key" in
        *A) # Up
          ((cursor--)) || true
          [[ $cursor -lt 0 ]] && cursor=0
          ;;
        *B) # Down
          ((cursor++)) || true
          ;;
        *C) # Right - expand (or go up on "..")
          [[ ${#visible_names[@]} -gt 0 ]] && nav_up_or_expand
          ;;
        *D) # Left - collapse (no-op on parent row)
          [[ ${#visible_names[@]} -eq 0 ]] && continue
          local path="${visible_paths[$cursor]}"
          local isdir=${visible_isdir[$cursor]}
          if [[ $cursor -eq 0 && "$ROOT" != "/" ]]; then
            :
          elif [[ $isdir -eq 1 ]]; then
            set_collapsed "$path"
          else
            # Move cursor to parent directory row if possible
            local depth=${visible_depths[$cursor]}
            local i=$cursor
            while [[ $i -gt 0 ]]; do
              ((i--)) || true
              if [[ ${visible_depths[$i]} -lt $depth && ${visible_isdir[$i]} -eq 1 ]]; then
                cursor=$i
                set_collapsed "${visible_paths[$i]}"
                break
              fi
            done
          fi
          ;;
      esac
    else
      case "$key" in
        'q'|'Q') exit 0 ;;
        'u'|'U') do_go_up ;;
        ''|$'\n'|$'\r')
          # Enter: row 0 when not at / is always "go up"; otherwise expand/collapse
          [[ ${#visible_names[@]} -eq 0 ]] && continue
          if [[ $cursor -eq 0 && "$ROOT" != "/" ]]; then
            do_go_up
          else
            local path="${visible_paths[$cursor]}"
            local isdir=${visible_isdir[$cursor]}
            if [[ $isdir -eq 1 ]]; then
              if is_expanded "$path"; then
                set_collapsed "$path"
              else
                set_expanded "$path"
              fi
            fi
          fi
          ;;
        'j') ((cursor++)) || true ;;
        'k') ((cursor--)) || true; [[ $cursor -lt 0 ]] && cursor=0 ;;
      esac
    fi
  done
}

# Start with root expanded so we see first level
expanded_paths="$ROOT"$'\n'
# Populate overview (home or root top dirs) in background so first keypress may show it
get_overview_data &
main_loop
