#!/usr/bin/env bash
#
# disky - Interactive disc space analysis with expandable tree view
# Usage: ./disky [directory]   OR   bash disky [directory]
# (Do not run with Python; this is a Bash script.)
#

# Don't use set -e: clear/du/read can fail in normal use (non-TTY, permissions)
set +e
IFS=$'\n'

# Colors (optional, can disable if terminal doesn't support)
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[1;33m'
BLUE=$'\033[0;34m'
CYAN=$'\033[0;36m'
BOLD=$'\033[1m'
DIM=$'\033[2m'
NORM=$'\033[0m'

# Box-drawing characters for tree
TREE_BRANCH="├── "
TREE_LAST="└── "
TREE_LINE="│   "
TREE_NONE="    "

# Bar width for disk gauge
BAR_WIDTH=28

# Config
ROOT="${1:-.}"
ROOT="$(cd "$ROOT" 2>/dev/null && pwd)" || { echo "Invalid directory: $1"; exit 1; }
CACHE_DIR="${TMPDIR:-/tmp}/disky_$$"
mkdir -p "$CACHE_DIR"
# Restore terminal on exit so keypresses don't echo as ^[[A etc.
saved_stty=""
trap 'rm -rf "$CACHE_DIR"; [[ -n "$saved_stty" ]] && stty "$saved_stty" 2>/dev/null' EXIT

# State
expanded_paths=""
cursor=0
tree_scroll_offset=0
NAVIGATING_UP=0
TREE_DIRTY=1
DISK_TOTAL="?"
DISK_USED="?"
DISK_AVAIL="?"
DISK_PCT=0
declare -a visible_depths visible_paths visible_names visible_sizes visible_isdir visible_expanded visible_has_sibling

# Chart view state (for per-directory usage chart)
CHART_ACTIVE=0
CHART_DIR=""
CHART_TOTAL_BYTES=0
CHART_MESSAGE=""
declare -a chart_labels chart_bytes

# Delete confirmation state
DELETE_CONFIRM_ACTIVE=0
DELETE_TARGET_PATH=""
DELETE_TARGET_NAME=""
DELETE_IS_DIR=0

# Reserve this many lines for header (gauge, title, help). Tree uses the rest.
HEADER_LINES=14

# For very large directories, skip expensive recursive size (`du`) per entry and
# fall back to fast, approximate sizes so navigation stays responsive.
LARGE_LIST_THRESHOLD=200

# Get disk stats for the volume containing path (total, used, avail, pct)
get_disk_stats() {
  local path="$1"
  local line
  line=$(df -h "$path" 2>/dev/null | awk 'NR==2')
  if [[ -z "$line" ]]; then
    echo "?" "?" "?" "0"
    return
  fi
  local total used avail pct
  total=$(echo "$line" | awk '{print $2}')
  used=$(echo "$line" | awk '{print $3}')
  avail=$(echo "$line" | awk '{print $4}')
  pct=$(echo "$line" | awk '{gsub(/%/,"",$5); print $5+0}')
  [[ -z "$pct" || "$pct" -lt 0 ]] && pct=0
  [[ "$pct" -gt 100 ]] && pct=100
  echo "$total" "$used" "$avail" "$pct"
}

# Refresh global disk stats for current ROOT (call this only when ROOT changes).
refresh_disk_stats() {
  local stats
  stats="$(get_disk_stats "$ROOT")"
  # Use a space IFS here so we correctly split the four fields from df,
  # without disturbing the global IFS (which is set to newline).
  local IFS=' '
  read -r DISK_TOTAL DISK_USED DISK_AVAIL DISK_PCT <<<"$stats"
}

# Draw ASCII art disk gauge (total / used / bar)
draw_disk_gauge() {
  local total="$1" used="$2" avail="$3" pct="$4"
  # Defensive: if all four values accidentally arrive in $1, split them.
  if [[ "$total" == *" "* && -z "$used" && -z "$avail" && -z "$pct" ]]; then
    set -- $total
    total="$1"
    used="$2"
    avail="$3"
    pct="$4"
  fi
  local filled empty i
  (( filled = (pct * BAR_WIDTH) / 100 )) || filled=0
  (( empty = BAR_WIDTH - filled )) || empty=BAR_WIDTH
  [[ $filled -gt $BAR_WIDTH ]] && filled=$BAR_WIDTH && empty=0
  [[ $empty -lt 0 ]] && empty=0
  echo -e "${DIM}     ___${NORM}\033[K"
  echo -e "${DIM}   /     \\${NORM}\033[K"
  echo -e "${DIM}  | ${BOLD}${CYAN}DISK${NORM}${DIM} |${NORM}\033[K"
  echo -e "${DIM}  |${NORM}   ${BOLD}Total:${NORM} ${YELLOW}$total${NORM}\033[K"
  echo -e "${DIM}  |${NORM}   ${BOLD}Used:${NORM}  ${RED}$used${NORM}\033[K"
  echo -e "${DIM}  |${NORM}   ${BOLD}Free:${NORM}  ${GREEN}$avail${NORM}\033[K"
  echo -e "${DIM}  |${NORM} ${GREEN}$(printf '%*s' "$filled" '' | tr ' ' '=')${NORM}${DIM}$(printf '%*s' "$empty" '' | tr ' ' '-')${NORM} ${DIM}|${NORM}  ${BOLD}${pct}%${NORM} used\033[K"
  echo -e "${DIM}   \\___/${NORM}\033[K"
}

# Render a simple horizontal "pie" chart for the currently selected directory.
# Uses global CHART_DIR, chart_labels, chart_bytes, CHART_TOTAL_BYTES, CHART_MESSAGE.
render_chart_view() {
  # Clear to a fresh screen so the chart is visually distinct from the tree.
  if command -v tput >/dev/null 2>&1; then
    tput clear 2>/dev/null || printf '\033[2J\033[H'
  else
    printf '\033[2J\033[H'
  fi

  # Header: overall disk gauge plus chart title/instructions.
  draw_disk_gauge "$DISK_TOTAL" "$DISK_USED" "$DISK_AVAIL" "$DISK_PCT"
  echo -e "\033[K"
  echo -e "${BOLD}${CYAN}disky${NORM} — usage inside ${DIM}$CHART_DIR${NORM}\033[K"
  echo -e "${DIM}c close chart  q quit${NORM}\033[K"
  echo -e "\033[K"

  if [[ -n "$CHART_MESSAGE" ]]; then
    echo -e "${YELLOW}$CHART_MESSAGE${NORM}\033[K"
    printf '\033[J'
    return
  fi

  local count=${#chart_labels[@]}
  if [[ $count -eq 0 || $CHART_TOTAL_BYTES -le 0 ]]; then
    echo -e "${YELLOW}No size data available for $CHART_DIR${NORM}\033[K"
    printf '\033[J'
    return
  fi

  local bar_width=40
  local i=0
  while [[ $i -lt $count ]]; do
    local label="${chart_labels[$i]}"
    local bytes=${chart_bytes[$i]}
    local pct=0
    if [[ $CHART_TOTAL_BYTES -gt 0 ]]; then
      pct=$(( bytes * 100 / CHART_TOTAL_BYTES ))
    fi
    if [[ $bytes -gt 0 && $pct -eq 0 ]]; then
      pct=1
    fi
    local filled=$(( pct * bar_width / 100 ))
    [[ $filled -lt 0 ]] && filled=0
    [[ $filled -gt $bar_width ]] && filled=$bar_width
    local empty=$(( bar_width - filled ))
    [[ $empty -lt 0 ]] && empty=0
    local bar
    bar="$(printf '%*s' "$filled" '' | tr ' ' '#')"
    bar="$bar$(printf '%*s' "$empty" '' | tr ' ' ' ')"
    local human
    human=$(bytes_to_human "$bytes")
    printf "  %-20s %5s%% [%s] %6s\033[K\n" "$label" "$pct" "$bar" "$human"
    ((i++)) || true
  done
  printf '\033[J'
}

# Render delete confirmation screen (clear screen, warning, Continue/No).
render_delete_confirm() {
  if command -v tput >/dev/null 2>&1; then
    tput clear 2>/dev/null || printf '\033[2J\033[H'
  else
    printf '\033[2J\033[H'
  fi

  echo -e "${BOLD}${RED}Delete${NORM}\033[K"
  echo -e "\033[K"
  echo -e "${YELLOW}Warning: This cannot be undone.${NORM}\033[K"
  echo -e "\033[K"
  if [[ $DELETE_IS_DIR -eq 1 ]]; then
    echo -e "  ${BOLD}Directory:${NORM} $DELETE_TARGET_PATH\033[K"
    echo -e "  ${DIM}(and all its contents will be removed)${NORM}\033[K"
  else
    echo -e "  ${BOLD}File:${NORM} $DELETE_TARGET_PATH\033[K"
  fi
  echo -e "\033[K"
  echo -e "  ${GREEN}[Enter / y]${NORM} Continue — delete\033[K"
  echo -e "  ${DIM}[n / Escape]${NORM} No — return to tree\033[K"
  printf '\033[J'
}

# Perform the actual delete and invalidate parent cache.
do_delete_target() {
  local parent_dir
  parent_dir="$(dirname "$DELETE_TARGET_PATH")"
  if [[ $DELETE_IS_DIR -eq 1 ]]; then
    rm -rf "$DELETE_TARGET_PATH" 2>/dev/null || true
  else
    rm -f "$DELETE_TARGET_PATH" 2>/dev/null || true
  fi
  # Invalidate cache for parent so tree refreshes
  local key
  key=$(path_to_cache_key "$parent_dir")
  rm -f "$CACHE_DIR/$key" 2>/dev/null || true
  TREE_DIRTY=1
}

# Convert bytes to human-readable (K/M/G) for fast file sizes.
bytes_to_human() {
  local bytes=$1
  if [[ $bytes -ge 1073741824 ]]; then
    echo "$(( bytes / 1073741824 ))G"
  elif [[ $bytes -ge 1048576 ]]; then
    echo "$(( bytes / 1048576 ))M"
  elif [[ $bytes -ge 1024 ]]; then
    echo "$(( bytes / 1024 ))K"
  else
    echo "${bytes}B"
  fi
}

# Build chart data for a given directory path into global chart_* vars.
build_chart_for_directory() {
  local dir="$1"
  CHART_MESSAGE=""
  CHART_TOTAL_BYTES=0
  chart_labels=()
  chart_bytes=()

  [[ -z "$dir" || ! -d "$dir" ]] && { CHART_MESSAGE="Not a directory: $dir"; return 1; }

  # Collect entries first to know how many we have.
  local -a items
  local item
  local count=0
  while IFS= read -r item; do
    [[ -z "$item" ]] && continue
    [[ "$item" == "." || "$item" == ".." ]] && continue
    items+=("$item")
    ((count++)) || true
  done < <(ls -A "$dir" 2>/dev/null)

  if [[ $count -eq 0 ]]; then
    CHART_MESSAGE="Directory is empty."
    return 0
  fi

  if [[ $count -gt $LARGE_LIST_THRESHOLD ]]; then
    CHART_MESSAGE="Directory has $count entries; chart disabled for performance."
    return 0
  fi

  local max_items_for_chart=30
  local total_bytes=0
  local other_bytes=0
  local other_count=0
  local idx=0

  for item in "${items[@]}"; do
    local full="$dir/$item"
    local size_bytes
    if [[ -d "$full" ]]; then
      # du -sk reports size in KiB; convert to bytes.
      local kb
      kb=$(du -sk "$full" 2>/dev/null | awk 'NR==1 {print $1}')
      [[ -z "$kb" ]] && kb=0
      size_bytes=$(( kb * 1024 ))
    else
      size_bytes=$(stat -f%z "$full" 2>/dev/null || echo "0")
      [[ "$size_bytes" == "?" ]] && size_bytes=0
    fi

    total_bytes=$(( total_bytes + size_bytes ))

    if [[ $idx -lt $max_items_for_chart ]]; then
      chart_labels+=( "$item" )
      chart_bytes+=( "$size_bytes" )
    else
      other_bytes=$(( other_bytes + size_bytes ))
      ((other_count++)) || true
    fi
    ((idx++)) || true
  done

  if [[ $other_bytes -gt 0 ]]; then
    chart_labels+=( "Other ($other_count more)" )
    chart_bytes+=( "$other_bytes" )
  fi

  CHART_TOTAL_BYTES=$total_bytes
  return 0
}

# Encode path for use as cache filename (safe for all chars)
path_to_cache_key() {
  echo -n "$1" | od -A n -t x1 | tr -d ' \n'
}

# Get directory listing with sizes (cached)
get_listing() {
  local path="$1"
  local key
  key=$(path_to_cache_key "$path")
  local cache_file="$CACHE_DIR/$key"
  if [[ -f "$cache_file" ]]; then
    cat "$cache_file"
    return
  fi
  local list=""
  if [[ ! -d "$path" ]]; then
    return
  fi

  # First collect entries so we know how many we have.
  local -a items
  local item
  local count=0
  while IFS= read -r item; do
    [[ -z "$item" ]] && continue
    [[ "$item" == "." || "$item" == ".." ]] && continue
    items+=("$item")
    ((count++)) || true
  done < <(ls -A "$path" 2>/dev/null)

  if [[ $count -eq 0 ]]; then
    echo -e "$list" > "$cache_file"
    echo -e "$list"
    return
  fi

  # For all directories, avoid recursive size (du) so expands are fast.
  # Use cheap stat only for files in reasonably sized directories.
  local full size type size_bytes
  if [[ $count -gt $LARGE_LIST_THRESHOLD ]]; then
    # Very large dir: no per-entry stat; just mark sizes as unknown.
    for item in "${items[@]}"; do
      full="$path/$item"
      if [[ -d "$full" ]]; then
        size="?"
        type="dir"
      else
        size="?"
        type="file"
      fi
      list="${list}${size}\t${item}\t${type}\n"
    done
  else
    # Small/medium dir: show real disk-usage for directories (du -sh, cached)
    # and cheap metadata size for files via stat.
    for item in "${items[@]}"; do
      full="$path/$item"
      if [[ -d "$full" ]]; then
        # Use du -sh for human readable directory size; fall back to "?" on error.
        size=$(du -sh "$full" 2>/dev/null | awk 'NR==1 {print $1}')
        [[ -z "$size" ]] && size="?"
        type="dir"
      else
        size_bytes=$(stat -f%z "$full" 2>/dev/null || echo "?")
        if [[ "$size_bytes" != "?" ]]; then
          size=$(bytes_to_human "$size_bytes")
        else
          size="?"
        fi
        type="file"
      fi
      list="${list}${size}\t${item}\t${type}\n"
    done
  fi

  echo -e "$list" > "$cache_file"
  echo -e "$list"
}

is_expanded() {
  local path="$1"
  case "$expanded_paths" in
    *$'\n'"$path"$'\n'*) return 0 ;;
    *$'\n'"$path") return 0 ;;
    "$path"$'\n'*) return 0 ;;
    "$path") return 0 ;;
    *) return 1 ;;
  esac
}

set_expanded() {
  local path="$1"
  if ! is_expanded "$path"; then
    expanded_paths="$expanded_paths$path"$'\n'
  fi
  TREE_DIRTY=1
}

set_collapsed() {
  local path="$1"
  # Remove this path and any path under it (safe for special chars in path)
  expanded_paths=$(echo "$expanded_paths" | while IFS= read -r p; do
    [[ -n "$p" && "$p" != "$path" && "$p" != "$path"/* ]] && echo "$p"
  done)
  TREE_DIRTY=1
}

# Build flattened visible tree (depths, paths, names, sizes, isdir, expanded, has_sibling)
build_visible_tree() {
  visible_depths=()
  visible_paths=()
  visible_names=()
  visible_sizes=()
  visible_isdir=()
  visible_expanded=()
  visible_has_sibling=()

  # ".." row to navigate up (only when not at filesystem root)
  if [[ "$ROOT" != "/" ]]; then
    local parent="${ROOT%/*}"
    [[ -z "$parent" ]] && parent="/"
    visible_depths+=(0)
    visible_paths+=("$parent")
    visible_names+=("..")
    visible_sizes+=("")
    visible_isdir+=(1)
    visible_expanded+=(0)
    visible_has_sibling+=(1)
  fi

  # Root row
  local root_size
  root_size=$(du -sh "$ROOT" 2>/dev/null | cut -f1) || root_size="?"
  visible_depths+=(0)
  visible_paths+=("$ROOT")
  visible_names+=(".")
  visible_sizes+=("${root_size:-?}")
  visible_isdir+=(1)
  visible_expanded+=(1)
  visible_has_sibling+=(1)  # root always has children below
  _build_visible "$ROOT" "." 1
}

_build_visible() {
  local path="$1"
  local name="$2"
  local depth=$3
  local listing line size n isdir has_sibling
  local -a names sizes isdirs paths

  if [[ -n "$name" ]]; then
    # Add this directory's children (directory itself was already added by parent)
    listing=$(get_listing "$path")
    if [[ -z "$listing" ]]; then
      # Empty or unreadable - nothing to add
      return
    fi
    # Count lines for has_sibling
    local count=0
    while IFS= read -r line; do
      [[ -z "$line" ]] && continue
      ((count++)) || true
    done <<< "$(echo -e "$listing")"
    local idx=0
    while IFS= read -r line; do
      [[ -z "$line" ]] && continue
      size=$(echo "$line" | cut -f1)
      n=$(echo "$line" | cut -f2)
      isdir=$(echo "$line" | cut -f3)
      ((idx++)) || true
      has_sibling=$(( idx < count ? 1 : 0 ))
      visible_depths+=("$depth")
      visible_paths+=("$path/$n")
      visible_names+=("$n")
      visible_sizes+=("$size")
      visible_isdir+=("$([[ "$isdir" == "dir" ]] && echo 1 || echo 0)")
      if [[ "$isdir" == "dir" ]]; then
        if is_expanded "$path/$n"; then
          visible_expanded+=("1")
          visible_has_sibling+=("$has_sibling")
          _build_visible "$path/$n" "$n" $(( depth + 1 ))
        else
          visible_expanded+=("0")
          visible_has_sibling+=("$has_sibling")
        fi
      else
        visible_expanded+=("0")
        visible_has_sibling+=("$has_sibling")
      fi
    done <<< "$(echo -e "$listing")"
    return
  fi
}

# Draw one line prefix (tree branches)
line_prefix() {
  local depth=$1
  local has_sibling=$2
  local d=0
  local out=""
  while [[ $d -lt $depth ]]; do
    # We need to know if any ancestor has a sibling - we don't have that here.
    # Use simple approach: all use TREE_LINE except at our depth.
    out="$out$TREE_LINE"
    ((d++)) || true
  done
  if [[ $has_sibling -eq 1 ]]; then
    out="$out$TREE_BRANCH"
  else
    out="$out$TREE_LAST"
  fi
  echo -n "$out"
}

render() {
  # Move cursor to top without clearing entire screen to avoid flashing
  local home
  home=$(tput home 2>/dev/null) || home=$'\033[H'
  printf '%s' "$home"
  # Disk gauge (total / used / free) for the volume containing ROOT
  draw_disk_gauge "$DISK_TOTAL" "$DISK_USED" "$DISK_AVAIL" "$DISK_PCT"
  echo -e "\033[K"
  echo -e "${BOLD}${CYAN}disky${NORM} — disc space — ${DIM}$ROOT${NORM}\033[K"
  echo -e "${DIM}↑/↓ move  Enter/→ expand  ← collapse  u up  g/p chart  d delete  q quit${NORM}\033[K"
  echo -e "\033[K"

  local total=${#visible_names[@]}
  # How many tree lines fit (same as clamp_cursor)
  local term_lines
  term_lines=$(tput lines 2>/dev/null)
  [[ -z "$term_lines" || "$term_lines" -lt 10 ]] && term_lines=24
  local tree_height=$(( term_lines - HEADER_LINES ))
  [[ $tree_height -lt 3 ]] && tree_height=3
  # If list fits, show all; else show viewport
  local start=0 end=$total
  if [[ $total -gt $tree_height ]]; then
    start=$tree_scroll_offset
    end=$(( tree_scroll_offset + tree_height ))
    [[ $end -gt $total ]] && end=$total
  fi
  local i=$start
  while [[ $i -lt $end ]]; do
    local depth=${visible_depths[$i]}
    local name="${visible_names[$i]}"
    local size="${visible_sizes[$i]}"
    local isdir=${visible_isdir[$i]}
    local expanded=${visible_expanded[$i]}
    local has_sibling=${visible_has_sibling[$i]}

    # Tree prefix: we need "has_sibling" per level from root to here.
    # Our array only has has_sibling for current node. So we use it for the last segment only.
    local prefix=""
    local d=0
    while [[ $d -lt $depth ]]; do
      prefix="$prefix$TREE_LINE"
      ((d++)) || true
    done
    if [[ $has_sibling -eq 1 ]]; then
      prefix="$prefix$TREE_BRANCH"
    else
      prefix="$prefix$TREE_LAST"
    fi

    local display_name="$name"
    [[ $isdir -eq 1 && "$name" != ".." ]] && display_name="$name/"
    [[ "$name" == ".." ]] && display_name=".. (parent)"

    if [[ $i -eq $cursor ]]; then
      if [[ "$name" == ".." ]]; then
        echo -e "${BOLD}${GREEN}> ${NORM}${prefix}${BOLD}${display_name}${NORM}  ${DIM}(go up)${NORM}\033[K"
      else
        echo -e "${BOLD}${GREEN}> ${NORM}${prefix}${BOLD}${display_name}${NORM}  ${YELLOW}${size}${NORM}\033[K"
      fi
    else
      if [[ "$name" == ".." ]]; then
        echo -e "  ${prefix}${DIM}${display_name}${NORM}  ${DIM}(go up)${NORM}\033[K"
      elif [[ $isdir -eq 1 ]]; then
        [[ $expanded -eq 1 ]] && echo -e "  ${prefix}${BLUE}${display_name}${NORM}  ${DIM}${size}${NORM}\033[K" || echo -e "  ${prefix}${CYAN}${display_name}${NORM}  ${DIM}${size}${NORM}\033[K"
      else
        echo -e "  ${prefix}${display_name}  ${DIM}${size}${NORM}\033[K"
      fi
    fi
    ((i++)) || true
  done
  if [[ $total -gt $tree_height ]]; then
    echo -e "${DIM}  — $(( start + 1 ))-$end of $total —${NORM}\033[K"
  fi
  # Clear any remaining content below the current cursor position to avoid visual artifacts
  printf '\033[J'
}

# Ensure cursor is in valid range; keep scroll so cursor stays in visible window.
clamp_cursor() {
  local total=${#visible_names[@]}
  if [[ $cursor -ge $total ]]; then
    cursor=$(( total - 1 ))
  fi
  [[ $cursor -lt 0 ]] && cursor=0
  # Viewport: how many tree lines fit on screen
  local term_lines
  term_lines=$(tput lines 2>/dev/null)
  [[ -z "$term_lines" || "$term_lines" -lt 10 ]] && term_lines=24
  local tree_height=$(( term_lines - HEADER_LINES ))
  [[ $tree_height -lt 3 ]] && tree_height=3
  # Keep cursor in view
  if [[ $cursor -lt $tree_scroll_offset ]]; then
    tree_scroll_offset=$cursor
  fi
  if [[ $cursor -ge $(( tree_scroll_offset + tree_height )) ]]; then
    tree_scroll_offset=$(( cursor - tree_height + 1 ))
  fi
  # Clamp scroll to valid range
  if [[ $(( tree_scroll_offset + tree_height )) -gt $total ]]; then
    tree_scroll_offset=$(( total - tree_height ))
  fi
  [[ $tree_scroll_offset -lt 0 ]] && tree_scroll_offset=0
}

# Go up to parent directory (same as "cd .." then show that directory).
do_go_up() {
  [[ "$ROOT" == "/" ]] && return
  local new_root
  new_root=$(cd "$ROOT/.." 2>/dev/null && pwd)
  if [[ -z "$new_root" ]]; then
    new_root="${ROOT%/*}"
    [[ -z "$new_root" ]] && new_root="/"
  fi
  ROOT="$new_root"
  expanded_paths="$ROOT"$'\n'
  cursor=0
  tree_scroll_offset=0
  NAVIGATING_UP=1
  TREE_DIRTY=1
  refresh_disk_stats
}

do_go_into() {
  local new_root="$1"
  [[ -z "$new_root" ]] && return
  [[ ! -d "$new_root" ]] && return
  ROOT="$new_root"
  expanded_paths="$ROOT"$'\n'
  cursor=0
  tree_scroll_offset=0
  NAVIGATING_UP=1
  TREE_DIRTY=1
  refresh_disk_stats
}

# Show loading screen while building tree (e.g. after navigating).
show_loading_screen() {
  clear 2>/dev/null || true
  echo -e "${BOLD}${CYAN}disky${NORM} — loading directory"
  echo ""
  echo -e "  ${YELLOW}Scanning:${NORM} $ROOT"
  echo ""
  echo -e "  ${DIM}Computing sizes (this may take a moment for large directories)...${NORM}"
  echo ""
}

# Navigate up (when on first row and not at /) or expand directory. Used by Enter and Right.
# Row 0 is always ".." when ROOT != "/", so we use index instead of name to avoid encoding issues.
nav_up_or_expand() {
  local total=${#visible_names[@]}
  [[ $total -eq 0 ]] && return
  if [[ $cursor -eq 0 && "$ROOT" != "/" ]]; then
    do_go_up
  else
    local path="${visible_paths[$cursor]}"
    local isdir=${visible_isdir[$cursor]}
    [[ $isdir -eq 1 ]] && do_go_into "$path"
  fi
}

main_loop() {
  local key
  saved_stty=$(stty -g 2>/dev/null)
  stty -icanon -echo 2>/dev/null
  while true; do
    if [[ $DELETE_CONFIRM_ACTIVE -eq 1 ]]; then
      render_delete_confirm
      key=""
      read -rsn 1 key || key="n"
      if [[ "$key" == $'\x1b' ]]; then
        read -rsn 2 key || key=""
        DELETE_CONFIRM_ACTIVE=0
        continue
      fi
      case "$key" in
        ''|$'\n'|$'\r'|'y'|'Y')
          do_delete_target
          ;;
        'n'|'N'|*)
          :
          ;;
      esac
      DELETE_CONFIRM_ACTIVE=0
      continue
    fi

    if [[ $CHART_ACTIVE -eq 0 ]]; then
      if [[ $TREE_DIRTY -eq 1 ]]; then
        if [[ $NAVIGATING_UP -eq 1 ]]; then
          show_loading_screen
          build_visible_tree
          NAVIGATING_UP=0
        else
          build_visible_tree
        fi
        TREE_DIRTY=0
      fi
      clamp_cursor
      render
    else
      # Chart view uses its own renderer; tree state is preserved.
      render_chart_view
    fi

    key=""
    read -rsn 1 key || key="q"

    # Open chart on 'g'/'G' (or ASCII 103/71) when in tree view
    keycode=$(printf '%d' "'$key" 2>/dev/null || echo "0")
    if [[ "${CHART_ACTIVE:-0}" -eq 0 ]]; then
      if [[ "$key" == "g" || "$key" == "G" || "$key" == "p" || "$key" == "P" || "$keycode" == "103" || "$keycode" == "71" || "$keycode" == "112" || "$keycode" == "80" ]]; then
        target_dir="$ROOT"
        if [[ ${#visible_names[@]} -gt 0 ]]; then
          row_path="${visible_paths[$cursor]}"
          if [[ -d "$row_path" ]]; then
            target_dir="$row_path"
          else
            target_dir=$(cd "$(dirname "$row_path")" 2>/dev/null && pwd)
            [[ -z "$target_dir" ]] && target_dir="$ROOT"
          fi
        fi
        if [[ -d "$target_dir" ]]; then
          CHART_DIR="$target_dir"
          build_chart_for_directory "$CHART_DIR"
          CHART_ACTIVE=1
        fi
        continue
      fi
    fi

    if [[ "$key" == $'\x1b' ]]; then
      read -rsn 2 key || key=""
      if [[ $CHART_ACTIVE -eq 0 ]]; then
        case "$key" in
          *A) # Up
            ((cursor--)) || true
            [[ $cursor -lt 0 ]] && cursor=0
            ;;
          *B) # Down
            ((cursor++)) || true
            ;;
          *C) # Right - expand (or go up on "..")
            [[ ${#visible_names[@]} -gt 0 ]] && nav_up_or_expand
            ;;
          *D) # Left - collapse (no-op on parent row)
            [[ ${#visible_names[@]} -eq 0 ]] && continue
            local path="${visible_paths[$cursor]}"
            local isdir=${visible_isdir[$cursor]}
            if [[ $cursor -eq 0 && "$ROOT" != "/" ]]; then
              :
            elif [[ $isdir -eq 1 ]]; then
              set_collapsed "$path"
            else
              # Move cursor to parent directory row if possible
              local depth=${visible_depths[$cursor]}
              local i=$cursor
              while [[ $i -gt 0 ]]; do
                ((i--)) || true
                if [[ ${visible_depths[$i]} -lt $depth && ${visible_isdir[$i]} -eq 1 ]]; then
                  cursor=$i
                  set_collapsed "${visible_paths[$i]}"
                  break
                fi
              done
            fi
            ;;
        esac
      fi
    else
      if [[ $CHART_ACTIVE -eq 1 ]]; then
        case "$key" in
          'q'|'Q') exit 0 ;;
          'c'|'C')
            # Close chart and return to tree view exactly as before.
            CHART_ACTIVE=0
            CHART_DIR=""
            TREE_DIRTY=1
            ;;
        esac
      else
        case "$key" in
          'q'|'Q') exit 0 ;;
          'u'|'U') do_go_up ;;
          ''|$'\n'|$'\r')
            # Enter: row 0 when not at / is always "go up"; otherwise enter directory
            [[ ${#visible_names[@]} -eq 0 ]] && continue
            if [[ $cursor -eq 0 && "$ROOT" != "/" ]]; then
              do_go_up
            else
              local path="${visible_paths[$cursor]}"
              local isdir=${visible_isdir[$cursor]}
              [[ $isdir -eq 1 ]] && do_go_into "$path"
            fi
            ;;
          'j') ((cursor++)) || true ;;
          'k') ((cursor--)) || true; [[ $cursor -lt 0 ]] && cursor=0 ;;
          'd'|'D')
            # Delete: cannot delete ".." or "." (current root row)
            if [[ ${#visible_names[@]} -gt 0 ]]; then
              local dname="${visible_names[$cursor]}"
              if [[ "$dname" != ".." && "$dname" != "." ]]; then
                DELETE_TARGET_PATH="${visible_paths[$cursor]}"
                DELETE_TARGET_NAME="$dname"
                DELETE_IS_DIR=${visible_isdir[$cursor]}
                DELETE_CONFIRM_ACTIVE=1
              fi
            fi
            ;;
          *)
            # Second chance: 'g'/'G' to open chart (in case early check missed it)
            if [[ "$key" == "g" || "$key" == "G" || "$key" == "p" || "$key" == "P" || "$keycode" == "103" || "$keycode" == "71" || "$keycode" == "112" || "$keycode" == "80" ]]; then
              target_dir="$ROOT"
              if [[ ${#visible_names[@]} -gt 0 ]]; then
                row_path="${visible_paths[$cursor]}"
                if [[ -d "$row_path" ]]; then
                  target_dir="$row_path"
                else
                  target_dir=$(cd "$(dirname "$row_path")" 2>/dev/null && pwd)
                  [[ -z "$target_dir" ]] && target_dir="$ROOT"
                fi
              fi
              if [[ -d "$target_dir" ]]; then
                CHART_DIR="$target_dir"
                build_chart_for_directory "$CHART_DIR"
                CHART_ACTIVE=1
              fi
            fi
            ;;
        esac
      fi
    fi
  done
}

# Start with root expanded so we see first level
expanded_paths="$ROOT"$'\n'
# Initial disk stats for current ROOT
refresh_disk_stats

# Clear the current screen buffer once before showing the interface
if command -v tput >/dev/null 2>&1; then
  tput clear 2>/dev/null || printf '\033[2J\033[H'
else
  printf '\033[2J\033[H'
fi

main_loop
