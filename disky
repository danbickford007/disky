#!/usr/bin/env bash
#
# disky - Interactive disc space analysis with expandable tree view
# Usage: ./disky [directory]   OR   bash disky [directory]
# (Do not run with Python; this is a Bash script.)
#

# Don't use set -e: clear/du/read can fail in normal use (non-TTY, permissions)
set +e
IFS=$'\n'

# Colors (optional, can disable if terminal doesn't support)
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[1;33m'
BLUE=$'\033[0;34m'
CYAN=$'\033[0;36m'
BOLD=$'\033[1m'
DIM=$'\033[2m'
NORM=$'\033[0m'

# Box-drawing characters for tree
TREE_BRANCH="├── "
TREE_LAST="└── "
TREE_LINE="│   "
TREE_NONE="    "

# Bar width for disk gauge
BAR_WIDTH=28

# Config
ROOT="${1:-.}"
ROOT="$(cd "$ROOT" 2>/dev/null && pwd)" || { echo "Invalid directory: $1"; exit 1; }
CACHE_DIR="${TMPDIR:-/tmp}/disky_$$"
mkdir -p "$CACHE_DIR"
# Restore terminal on exit so keypresses don't echo as ^[[A etc.
saved_stty=""
trap 'rm -rf "$CACHE_DIR"; [[ -n "$saved_stty" ]] && stty "$saved_stty" 2>/dev/null' EXIT

# State
expanded_paths=""
cursor=0
tree_scroll_offset=0
NAVIGATING_UP=0
TREE_DIRTY=1
DISK_TOTAL="?"
DISK_USED="?"
DISK_AVAIL="?"
DISK_PCT=0
declare -a visible_depths visible_paths visible_names visible_sizes visible_isdir visible_expanded visible_has_sibling

# Reserve this many lines for header (gauge, title, help). Tree uses the rest.
HEADER_LINES=14

# For very large directories, skip expensive recursive size (`du`) per entry and
# fall back to fast, approximate sizes so navigation stays responsive.
LARGE_LIST_THRESHOLD=200

# Get disk stats for the volume containing path (total, used, avail, pct)
get_disk_stats() {
  local path="$1"
  local line
  line=$(df -h "$path" 2>/dev/null | awk 'NR==2')
  if [[ -z "$line" ]]; then
    echo "?" "?" "?" "0"
    return
  fi
  local total used avail pct
  total=$(echo "$line" | awk '{print $2}')
  used=$(echo "$line" | awk '{print $3}')
  avail=$(echo "$line" | awk '{print $4}')
  pct=$(echo "$line" | awk '{gsub(/%/,"",$5); print $5+0}')
  [[ -z "$pct" || "$pct" -lt 0 ]] && pct=0
  [[ "$pct" -gt 100 ]] && pct=100
  echo "$total" "$used" "$avail" "$pct"
}

# Refresh global disk stats for current ROOT (call this only when ROOT changes).
refresh_disk_stats() {
  local stats
  stats="$(get_disk_stats "$ROOT")"
  # Use a space IFS here so we correctly split the four fields from df,
  # without disturbing the global IFS (which is set to newline).
  local IFS=' '
  read -r DISK_TOTAL DISK_USED DISK_AVAIL DISK_PCT <<<"$stats"
}

# Draw ASCII art disk gauge (total / used / bar)
draw_disk_gauge() {
  local total="$1" used="$2" avail="$3" pct="$4"
  # Defensive: if all four values accidentally arrive in $1, split them.
  if [[ "$total" == *" "* && -z "$used" && -z "$avail" && -z "$pct" ]]; then
    set -- $total
    total="$1"
    used="$2"
    avail="$3"
    pct="$4"
  fi
  local filled empty i
  (( filled = (pct * BAR_WIDTH) / 100 )) || filled=0
  (( empty = BAR_WIDTH - filled )) || empty=BAR_WIDTH
  [[ $filled -gt $BAR_WIDTH ]] && filled=$BAR_WIDTH && empty=0
  [[ $empty -lt 0 ]] && empty=0
  echo -e "${DIM}     ___${NORM}\033[K"
  echo -e "${DIM}   /     \\${NORM}\033[K"
  echo -e "${DIM}  | ${BOLD}${CYAN}DISK${NORM}${DIM} |${NORM}\033[K"
  echo -e "${DIM}  |${NORM}   ${BOLD}Total:${NORM} ${YELLOW}$total${NORM}\033[K"
  echo -e "${DIM}  |${NORM}   ${BOLD}Used:${NORM}  ${RED}$used${NORM}\033[K"
  echo -e "${DIM}  |${NORM}   ${BOLD}Free:${NORM}  ${GREEN}$avail${NORM}\033[K"
  echo -e "${DIM}  |${NORM} ${GREEN}$(printf '%*s' "$filled" '' | tr ' ' '=')${NORM}${DIM}$(printf '%*s' "$empty" '' | tr ' ' '-')${NORM} ${DIM}|${NORM}  ${BOLD}${pct}%${NORM} used\033[K"
  echo -e "${DIM}   \\___/${NORM}\033[K"
}

# Convert bytes to human-readable (K/M/G) for fast file sizes.
bytes_to_human() {
  local bytes=$1
  if [[ $bytes -ge 1073741824 ]]; then
    echo "$(( bytes / 1073741824 ))G"
  elif [[ $bytes -ge 1048576 ]]; then
    echo "$(( bytes / 1048576 ))M"
  elif [[ $bytes -ge 1024 ]]; then
    echo "$(( bytes / 1024 ))K"
  else
    echo "${bytes}B"
  fi
}

# Encode path for use as cache filename (safe for all chars)
path_to_cache_key() {
  echo -n "$1" | od -A n -t x1 | tr -d ' \n'
}

# Get directory listing with sizes (cached)
get_listing() {
  local path="$1"
  local key
  key=$(path_to_cache_key "$path")
  local cache_file="$CACHE_DIR/$key"
  if [[ -f "$cache_file" ]]; then
    cat "$cache_file"
    return
  fi
  local list=""
  if [[ ! -d "$path" ]]; then
    return
  fi

  # First collect entries so we know how many we have.
  local -a items
  local item
  local count=0
  while IFS= read -r item; do
    [[ -z "$item" ]] && continue
    [[ "$item" == "." || "$item" == ".." ]] && continue
    items+=("$item")
    ((count++)) || true
  done < <(ls -A "$path" 2>/dev/null)

  if [[ $count -eq 0 ]]; then
    echo -e "$list" > "$cache_file"
    echo -e "$list"
    return
  fi

  # For all directories, avoid recursive size (du) so expands are fast.
  # Use cheap stat only for files in reasonably sized directories.
  local full size type size_bytes
  if [[ $count -gt $LARGE_LIST_THRESHOLD ]]; then
    # Very large dir: no per-entry stat; just mark sizes as unknown.
    for item in "${items[@]}"; do
      full="$path/$item"
      if [[ -d "$full" ]]; then
        size="?"
        type="dir"
      else
        size="?"
        type="file"
      fi
      list="${list}${size}\t${item}\t${type}\n"
    done
  else
    # Small/medium dir: show real disk-usage for directories (du -sh, cached)
    # and cheap metadata size for files via stat.
    for item in "${items[@]}"; do
      full="$path/$item"
      if [[ -d "$full" ]]; then
        # Use du -sh for human readable directory size; fall back to "?" on error.
        size=$(du -sh "$full" 2>/dev/null | awk 'NR==1 {print $1}')
        [[ -z "$size" ]] && size="?"
        type="dir"
      else
        size_bytes=$(stat -f%z "$full" 2>/dev/null || echo "?")
        if [[ "$size_bytes" != "?" ]]; then
          size=$(bytes_to_human "$size_bytes")
        else
          size="?"
        fi
        type="file"
      fi
      list="${list}${size}\t${item}\t${type}\n"
    done
  fi

  echo -e "$list" > "$cache_file"
  echo -e "$list"
}

is_expanded() {
  local path="$1"
  case "$expanded_paths" in
    *$'\n'"$path"$'\n'*) return 0 ;;
    *$'\n'"$path") return 0 ;;
    "$path"$'\n'*) return 0 ;;
    "$path") return 0 ;;
    *) return 1 ;;
  esac
}

set_expanded() {
  local path="$1"
  if ! is_expanded "$path"; then
    expanded_paths="$expanded_paths$path"$'\n'
  fi
  TREE_DIRTY=1
}

set_collapsed() {
  local path="$1"
  # Remove this path and any path under it (safe for special chars in path)
  expanded_paths=$(echo "$expanded_paths" | while IFS= read -r p; do
    [[ -n "$p" && "$p" != "$path" && "$p" != "$path"/* ]] && echo "$p"
  done)
  TREE_DIRTY=1
}

# Build flattened visible tree (depths, paths, names, sizes, isdir, expanded, has_sibling)
build_visible_tree() {
  visible_depths=()
  visible_paths=()
  visible_names=()
  visible_sizes=()
  visible_isdir=()
  visible_expanded=()
  visible_has_sibling=()

  # ".." row to navigate up (only when not at filesystem root)
  if [[ "$ROOT" != "/" ]]; then
    local parent="${ROOT%/*}"
    [[ -z "$parent" ]] && parent="/"
    visible_depths+=(0)
    visible_paths+=("$parent")
    visible_names+=("..")
    visible_sizes+=("")
    visible_isdir+=(1)
    visible_expanded+=(0)
    visible_has_sibling+=(1)
  fi

  # Root row
  local root_size
  root_size=$(du -sh "$ROOT" 2>/dev/null | cut -f1) || root_size="?"
  visible_depths+=(0)
  visible_paths+=("$ROOT")
  visible_names+=(".")
  visible_sizes+=("${root_size:-?}")
  visible_isdir+=(1)
  visible_expanded+=(1)
  visible_has_sibling+=(1)  # root always has children below
  _build_visible "$ROOT" "." 1
}

_build_visible() {
  local path="$1"
  local name="$2"
  local depth=$3
  local listing line size n isdir has_sibling
  local -a names sizes isdirs paths

  if [[ -n "$name" ]]; then
    # Add this directory's children (directory itself was already added by parent)
    listing=$(get_listing "$path")
    if [[ -z "$listing" ]]; then
      # Empty or unreadable - nothing to add
      return
    fi
    # Count lines for has_sibling
    local count=0
    while IFS= read -r line; do
      [[ -z "$line" ]] && continue
      ((count++)) || true
    done <<< "$(echo -e "$listing")"
    local idx=0
    while IFS= read -r line; do
      [[ -z "$line" ]] && continue
      size=$(echo "$line" | cut -f1)
      n=$(echo "$line" | cut -f2)
      isdir=$(echo "$line" | cut -f3)
      ((idx++)) || true
      has_sibling=$(( idx < count ? 1 : 0 ))
      visible_depths+=("$depth")
      visible_paths+=("$path/$n")
      visible_names+=("$n")
      visible_sizes+=("$size")
      visible_isdir+=("$([[ "$isdir" == "dir" ]] && echo 1 || echo 0)")
      if [[ "$isdir" == "dir" ]]; then
        if is_expanded "$path/$n"; then
          visible_expanded+=("1")
          visible_has_sibling+=("$has_sibling")
          _build_visible "$path/$n" "$n" $(( depth + 1 ))
        else
          visible_expanded+=("0")
          visible_has_sibling+=("$has_sibling")
        fi
      else
        visible_expanded+=("0")
        visible_has_sibling+=("$has_sibling")
      fi
    done <<< "$(echo -e "$listing")"
    return
  fi
}

# Draw one line prefix (tree branches)
line_prefix() {
  local depth=$1
  local has_sibling=$2
  local d=0
  local out=""
  while [[ $d -lt $depth ]]; do
    # We need to know if any ancestor has a sibling - we don't have that here.
    # Use simple approach: all use TREE_LINE except at our depth.
    out="$out$TREE_LINE"
    ((d++)) || true
  done
  if [[ $has_sibling -eq 1 ]]; then
    out="$out$TREE_BRANCH"
  else
    out="$out$TREE_LAST"
  fi
  echo -n "$out"
}

render() {
  # Move cursor to top without clearing entire screen to avoid flashing
  local home
  home=$(tput home 2>/dev/null) || home=$'\033[H'
  printf '%s' "$home"
  # Disk gauge (total / used / free) for the volume containing ROOT
  draw_disk_gauge "$DISK_TOTAL" "$DISK_USED" "$DISK_AVAIL" "$DISK_PCT"
  echo -e "\033[K"
  echo -e "${BOLD}${CYAN}disky${NORM} — disc space — ${DIM}$ROOT${NORM}\033[K"
  echo -e "${DIM}↑/↓ move  Enter/→ expand  ← collapse  u up  q quit${NORM}\033[K"
  echo -e "\033[K"

  local total=${#visible_names[@]}
  # How many tree lines fit (same as clamp_cursor)
  local term_lines
  term_lines=$(tput lines 2>/dev/null)
  [[ -z "$term_lines" || "$term_lines" -lt 10 ]] && term_lines=24
  local tree_height=$(( term_lines - HEADER_LINES ))
  [[ $tree_height -lt 3 ]] && tree_height=3
  # If list fits, show all; else show viewport
  local start=0 end=$total
  if [[ $total -gt $tree_height ]]; then
    start=$tree_scroll_offset
    end=$(( tree_scroll_offset + tree_height ))
    [[ $end -gt $total ]] && end=$total
  fi
  local i=$start
  while [[ $i -lt $end ]]; do
    local depth=${visible_depths[$i]}
    local name="${visible_names[$i]}"
    local size="${visible_sizes[$i]}"
    local isdir=${visible_isdir[$i]}
    local expanded=${visible_expanded[$i]}
    local has_sibling=${visible_has_sibling[$i]}

    # Tree prefix: we need "has_sibling" per level from root to here.
    # Our array only has has_sibling for current node. So we use it for the last segment only.
    local prefix=""
    local d=0
    while [[ $d -lt $depth ]]; do
      prefix="$prefix$TREE_LINE"
      ((d++)) || true
    done
    if [[ $has_sibling -eq 1 ]]; then
      prefix="$prefix$TREE_BRANCH"
    else
      prefix="$prefix$TREE_LAST"
    fi

    local display_name="$name"
    [[ $isdir -eq 1 && "$name" != ".." ]] && display_name="$name/"
    [[ "$name" == ".." ]] && display_name=".. (parent)"

    if [[ $i -eq $cursor ]]; then
      if [[ "$name" == ".." ]]; then
        echo -e "${BOLD}${GREEN}> ${NORM}${prefix}${BOLD}${display_name}${NORM}  ${DIM}(go up)${NORM}\033[K"
      else
        echo -e "${BOLD}${GREEN}> ${NORM}${prefix}${BOLD}${display_name}${NORM}  ${YELLOW}${size}${NORM}\033[K"
      fi
    else
      if [[ "$name" == ".." ]]; then
        echo -e "  ${prefix}${DIM}${display_name}${NORM}  ${DIM}(go up)${NORM}\033[K"
      elif [[ $isdir -eq 1 ]]; then
        [[ $expanded -eq 1 ]] && echo -e "  ${prefix}${BLUE}${display_name}${NORM}  ${DIM}${size}${NORM}\033[K" || echo -e "  ${prefix}${CYAN}${display_name}${NORM}  ${DIM}${size}${NORM}\033[K"
      else
        echo -e "  ${prefix}${display_name}  ${DIM}${size}${NORM}\033[K"
      fi
    fi
    ((i++)) || true
  done
  if [[ $total -gt $tree_height ]]; then
    echo -e "${DIM}  — $(( start + 1 ))-$end of $total —${NORM}\033[K"
  fi
  # Clear any remaining content below the current cursor position to avoid visual artifacts
  printf '\033[J'
}

# Ensure cursor is in valid range; keep scroll so cursor stays in visible window.
clamp_cursor() {
  local total=${#visible_names[@]}
  if [[ $cursor -ge $total ]]; then
    cursor=$(( total - 1 ))
  fi
  [[ $cursor -lt 0 ]] && cursor=0
  # Viewport: how many tree lines fit on screen
  local term_lines
  term_lines=$(tput lines 2>/dev/null)
  [[ -z "$term_lines" || "$term_lines" -lt 10 ]] && term_lines=24
  local tree_height=$(( term_lines - HEADER_LINES ))
  [[ $tree_height -lt 3 ]] && tree_height=3
  # Keep cursor in view
  if [[ $cursor -lt $tree_scroll_offset ]]; then
    tree_scroll_offset=$cursor
  fi
  if [[ $cursor -ge $(( tree_scroll_offset + tree_height )) ]]; then
    tree_scroll_offset=$(( cursor - tree_height + 1 ))
  fi
  # Clamp scroll to valid range
  if [[ $(( tree_scroll_offset + tree_height )) -gt $total ]]; then
    tree_scroll_offset=$(( total - tree_height ))
  fi
  [[ $tree_scroll_offset -lt 0 ]] && tree_scroll_offset=0
}

# Go up to parent directory (same as "cd .." then show that directory).
do_go_up() {
  [[ "$ROOT" == "/" ]] && return
  local new_root
  new_root=$(cd "$ROOT/.." 2>/dev/null && pwd)
  if [[ -z "$new_root" ]]; then
    new_root="${ROOT%/*}"
    [[ -z "$new_root" ]] && new_root="/"
  fi
  ROOT="$new_root"
  expanded_paths="$ROOT"$'\n'
  cursor=0
  tree_scroll_offset=0
  NAVIGATING_UP=1
  TREE_DIRTY=1
  refresh_disk_stats
}

do_go_into() {
  local new_root="$1"
  [[ -z "$new_root" ]] && return
  [[ ! -d "$new_root" ]] && return
  ROOT="$new_root"
  expanded_paths="$ROOT"$'\n'
  cursor=0
  tree_scroll_offset=0
  NAVIGATING_UP=1
  TREE_DIRTY=1
  refresh_disk_stats
}

# Show loading screen while building tree (e.g. after navigating).
show_loading_screen() {
  clear 2>/dev/null || true
  echo -e "${BOLD}${CYAN}disky${NORM} — loading directory"
  echo ""
  echo -e "  ${YELLOW}Scanning:${NORM} $ROOT"
  echo ""
  echo -e "  ${DIM}Computing sizes (this may take a moment for large directories)...${NORM}"
  echo ""
}

# Navigate up (when on first row and not at /) or expand directory. Used by Enter and Right.
# Row 0 is always ".." when ROOT != "/", so we use index instead of name to avoid encoding issues.
nav_up_or_expand() {
  local total=${#visible_names[@]}
  [[ $total -eq 0 ]] && return
  if [[ $cursor -eq 0 && "$ROOT" != "/" ]]; then
    do_go_up
  else
    local path="${visible_paths[$cursor]}"
    local isdir=${visible_isdir[$cursor]}
    [[ $isdir -eq 1 ]] && do_go_into "$path"
  fi
}

main_loop() {
  local key
  saved_stty=$(stty -g 2>/dev/null)
  stty -icanon -echo 2>/dev/null
  while true; do
    if [[ $TREE_DIRTY -eq 1 ]]; then
      if [[ $NAVIGATING_UP -eq 1 ]]; then
        show_loading_screen
        build_visible_tree
        NAVIGATING_UP=0
      else
        build_visible_tree
      fi
      TREE_DIRTY=0
    fi
    clamp_cursor
    render

    key=""
    read -rsn 1 key || key="q"
    if [[ "$key" == $'\x1b' ]]; then
      read -rsn 2 key || key=""
      case "$key" in
        *A) # Up
          ((cursor--)) || true
          [[ $cursor -lt 0 ]] && cursor=0
          ;;
        *B) # Down
          ((cursor++)) || true
          ;;
        *C) # Right - expand (or go up on "..")
          [[ ${#visible_names[@]} -gt 0 ]] && nav_up_or_expand
          ;;
        *D) # Left - collapse (no-op on parent row)
          [[ ${#visible_names[@]} -eq 0 ]] && continue
          local path="${visible_paths[$cursor]}"
          local isdir=${visible_isdir[$cursor]}
          if [[ $cursor -eq 0 && "$ROOT" != "/" ]]; then
            :
          elif [[ $isdir -eq 1 ]]; then
            set_collapsed "$path"
          else
            # Move cursor to parent directory row if possible
            local depth=${visible_depths[$cursor]}
            local i=$cursor
            while [[ $i -gt 0 ]]; do
              ((i--)) || true
              if [[ ${visible_depths[$i]} -lt $depth && ${visible_isdir[$i]} -eq 1 ]]; then
                cursor=$i
                set_collapsed "${visible_paths[$i]}"
                break
              fi
            done
          fi
          ;;
      esac
    else
      case "$key" in
        'q'|'Q') exit 0 ;;
        'u'|'U') do_go_up ;;
        ''|$'\n'|$'\r')
          # Enter: row 0 when not at / is always "go up"; otherwise enter directory
          [[ ${#visible_names[@]} -eq 0 ]] && continue
          if [[ $cursor -eq 0 && "$ROOT" != "/" ]]; then
            do_go_up
          else
            local path="${visible_paths[$cursor]}"
            local isdir=${visible_isdir[$cursor]}
            [[ $isdir -eq 1 ]] && do_go_into "$path"
          fi
          ;;
        'j') ((cursor++)) || true ;;
        'k') ((cursor--)) || true; [[ $cursor -lt 0 ]] && cursor=0 ;;
      esac
    fi
  done
}

# Start with root expanded so we see first level
expanded_paths="$ROOT"$'\n'
# Initial disk stats for current ROOT
refresh_disk_stats

# Clear the current screen buffer once before showing the interface
if command -v tput >/dev/null 2>&1; then
  tput clear 2>/dev/null || printf '\033[2J\033[H'
else
  printf '\033[2J\033[H'
fi

main_loop
